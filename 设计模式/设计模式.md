# 设计模式
- 设计模式至少包含
    1. 模式名称 ( pattern name )
    2. 问题 ( problem )
    3. 解决方案 ( solution )
    4. 效果 ( consequence )
    
## 模式列表
1. Factory method 模式, 工厂方法模式提供了一种延迟创建类的方法,使用这个方法可以在运行期由子类决定创建那个类的实例
2. Abstract Factory 模式, 抽象工厂模式，该模式主要为解决复杂系统中对象创建的问题. 
    抽象工厂模式提供了一个一致的对象创建接口来创建一系列具有相似基类或相似接口的对象
3. builder 模式, 创建者模式, 是逐步地构造出一个复杂对象，并在最后返回对象的实例. build 模式可以把复杂对象的创建与表示分离,使得同样的创建过程可以创建不同的表示
4. prototype 模式, 原型模式，可以根据原型实例制定创建对象的种类,并通过深度复制这个原型来创建新的对象
5. singleton 模式，单例模式，使用 singleton 模式可以保证一个类仅有一个实例，从而可以提供一个单一的全局访问点
6. adapter 模式 ，适配器模式,适配器模式可以解决系统间接口不兼容的问题
7. bridge 模式 ，桥接模式, 桥接模式把类的抽象部分同实现部分相分离，
8. composite 模式, 组合模式 ，组合模式提供了一种以树形结构组合对象的方法，使用 composite 模式可以使单个对象和组合后的对象具有一致性以提高软件的复用性
9. decorator 模式 ，装饰器模式, 装饰器模式可以动态的为对象的某一个方法增加更多的功能
10. facade 模式 门面模式，外观模式, facade 模式为一组类提供了一致的访问接口. 使用 facade 可以封装内部具有不同接口的类，使其对外提供统一的访问方式
11. flyweight 模式 享元模式，共享大量的细粒度对象，从而节省创建对象所需要分配的空间，不过在时间上开销会变大
12. proxy 模式 , 代理模式, 代理模式为对象提供了一种访问代理，通过对象 proxy 可以控制客户端程序的访问
13. interpreter 模式，解释器模式, 定义了一个解释器, 来解释遵循给定语言和文法的句子
14. template method 模式，模板模式 定义了一个操作模板，其中的一些步骤会在子类实现，适应不同的祖杭太
15. chain of responsibility 模式 , 责任链模式， 把响应请求的对象组织成一条链，并在这条对象链上传递请求，从而保证多个对象都有机会处理请求而且可以避免请求方和相应方的耦合
16. command 模式，命令模式，将请求封装为对象，从而增强请求的能力，
17. iterator 模式 ， 迭代器模式, 迭代器模式提供了顺序访问一个对象集合中的各元素的方法
18. mediator 模式, 中介者模式，中介者模式可以减少系统中对象间的耦合性，中介模式使用中介对象封装其他对象，从而使这些被封装的对象间的关系成了松散耦合
19. memento 模式, 备忘录模式, 备忘录模式提供了一种捕获对象状态的方法，且不会破坏对象的封装，并且可以在对象外部保存对象的状态，并在需要的时候恢复对象状态
20. observer 模式，观察者模式, 观察者模式提供了将对象的状态广播到一组观察者的方式，从而可以让每个观察者随时可以得到对象的更新通知
21. state 模式 ，状态模式, 状态模式允许一个对象在其内部状态改变的时候改变他的行为
22. strategy 模式，策略模式 使用策略模式可以让对象中算法的变化独立于客户
23. visitor 模式，访问者模式， 对某对象结构中各元素的操作，使用 visitor 模式可以在不改变各元素类的前提下定义作用域这些元素的新操作



## 设计模式与软件架构
- 4+1视图, 将软件架构通过**逻辑视图、开发试图、进程视图、物理视图及场景视图来进行描述**

### 设计模式的分类
1. 创建型
    - factory method
    - abstract factory
    - builder
    - prototype
    - singleton
2. 结构型
    - adapter
    - bridge
    - composite
    - decorator
    - facade
    - flyweight
    - proxy 
3. 行为型
    - interpreter
    - template method
    - chain of responsibility
    - command
    - iterator
    - mediator
    - memento
    - observer
    - state
    - strategy
    - visitor


## facade 模式
- 解决这样一个问题
    在一个程序中会调用若干个子系统,在不做处理的时候需要了解每个子系统的接口，并使用这些接口进行调用
    facade 模式通过在原有程序和若干个子系统上创建一层风法，封装这些子系统的接口，提供对外的一致性接口    
    
    
## mediator 中介模式
- 在一个复杂系统中会有很多对象, 这些对象之间会互相通讯，从而造成对象的互相依赖, 修改其中一个对象会影响若干个对象