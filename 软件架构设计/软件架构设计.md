# 软件架构设计
## 定义
1. 软件或计算机系统的软件架构是该系统的一个(或多个)结构,而结构由软件元素、元素的外部可见属性及他们之间的关系组成
2. 软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统元素的描述、这些元素的互相作用、指导元素集成的模式及这些模式的约束组成
3. 软件架构是指一个系统的基础组织，它具体体现在: 系统的构建。构件之间、构建与环境之间的关系，以及指导其设计和演化的原则上

## 架构模型
### 结构模型
- 这是一个最直观、最普遍的建模方式。这种方法以架构的组件、连接件和其他概念来刻画结构,并力图通过结构来反映系统的重要语义内容,包括系统的配置、约束、隐含的假设条件、风格、性质。

### 框架模型
- 框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于整体的结构。框架模型主要以一些特殊的问题为目标建立只针对和适应该问题的结构

### 动态模型
- 动态模型是对结构或框架模型的补充，研究系统"大颗粒"的行为性质.

### 过程模型
- 过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本的结果

### 功能模型
- 该模型认为架构由一组功能构件按层次组成，且下层向上层提供服务


### 4+1 视图
1. 逻辑视图
    主要支持系统的功能需求,即系统提供给最终用户的服务.
    在逻辑视图中,系统分解成一系列的功能抽象,这些抽象主要来自问题领域.
    在面向对象技术中,通过抽象、封装和集成，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。
    逻辑视图中使用的风格为面向对象的风格,逻辑视图设计中要主要的主要问题是要保持一个单一的、内聚的对象模型贯穿整个系统
2. 开发试图(模块视图)
    主要侧重于软件模块的组织和管理.
3. 进程视图
    侧重于系统的运行特性,主要关注一些非功能性的需求
    进程视图强调: 并发性、分布性、系统继承性和容错能力
4. 物理视图
    考虑如何把软件映射到硬件上,它通常要考虑到解决系统拓扑结构、系统安装、通信的问题
5. 场景
    重要系统活动的抽象，它使四个视图有机的联系起来
    场景是最重要的需求抽象
    
逻辑视图和开发视图描述系统的静态结构。进程视图和物理视图描述系统的动态结构

## 软件质量属性
- 软件质量特性包括: **功能性、可靠性、易用性、效率、可维护性、可移植性**
- 功能性
    - 适合性
    - 准确性
    - 互操作性
    - 依从性
    - 安全性
- 可靠性
    - 成熟性
    - 容错性
    - 易恢复性
- 易用性
    - 易理解性
    - 易学性
    - 易操作性
- 效率
    - 时间特性
    - 资源特性
- 可维护性
    - 易分析性
    - 易改变性
    - 稳定性
    - 易测试性
- 可移植性
    - 适应性
    - 易安装性
    - 遵循性
    - 易替换性
    
    
## 软件架构风格
- 分类
1. 数据流风格
    批处理序列, 管道-过滤器
2. 调用/返回风格
    主程序-子程序。
    面向对象风格: 层次结构
3. 独立构件风格
    进程通信
    事件系统
4. 虚拟机风格
    解释器
    基于规则的系统
5. 仓库风格
    数据库系统
    超文本系统
    黑板系统
    
### 数据流风格
#### 批处理序列
- 批处理风格的每一步都是独立的,并且每一步都是顺序执行,数据传送在步与步之间作为整体
典型应用
1. 经典数据处理
2. 程序开发
3. windows bat 脚本

#### 管道和过滤器
- 每个构件都有一组输入和输出,构件读输入shu的数据流,经过内部处理然后产生输出流
特点
1. 是的软构件具有良好的隐蔽性和高内聚、低耦合的特点
2. 允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成
3. 支持软件重用. 只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可以被连接起来
4. 系统维护和增强系统性能简单.新的过滤器可以添加到现有系统中来,旧的可以被改进的过滤器替换
5. 允许对吞吐量,死锁等属性的分析
6. 支持并行执行.每个过滤器是作为一个单独的任务完成.
缺点
1. 导致进程成为批处理的结构.
2. 不适合处理交互的应用
3. 因为在数据传输上没有通用的标准,每个过滤器都增加了解析和合成数据的工作，导致系统性能下降,并增加了编写过滤器的复杂性


#### 对比
- 共同点:
    1. 把任务分成一系列固定顺序的计算单元,组件之间只通过数据传递交互
- 区别
    1. 批处理是全部的,搞潜伏性的,输入时可以随机存取,无合作性、无交互性、
        管道-过滤器时递增的,数据结果延迟小,输入时处理局部变化,有反馈、可交互.
    2. 批处理强调数据传输在步与步之间作为一个整体,管道-过滤器没有这个要求
    

### 调用/返回风格
- 指在系统中采用了调用与返回机制.利用调用-返回,实际上是一种分而治之的策略,主要思想**将一个复杂的大系统分解为一些子系统,以便降低复杂度,并且增加可修改性.**
  
#### 主程序/子程序
- 结构化开发时期的经典架构风格. 这种风格一般采用单线程控制,把问题划分为若干处理步骤,构件即为主程序和子程序。子程序通常可以合成为模块

#### 面向对象风格
- 这种风格建立在数据抽象和面向对象的基础上,数据的表示方法和他们的相应操作封装在一个抽象数据类型或对象中.
- 特征
    1. 对象负责维护其表示的完整性
    2. 对象的表示对其他对象而言时隐蔽的
- 优点
    1. 因为对象对其他隐藏的表示,所以可以改变一个对象的表示，而不影响其他的对象
    2. 设计者可将一些数据的存取操作问题分解成为一些交互的代理程序集合
- 问题
    1. 为了使一个对象和另一个对象通过过程调用等进行交互,必须知道对象的标识,只要一个对象的标识变了,就必须修改所有其他明确调用它的对象
    2. 必须修改所有显式调用它的其他对象,并消除由此带来的副作用
    
#### 层次结构风格
- 层次系统组织成一个层次结构,每一层为上层服务,并最为下层客户
- 这种风格支持基于可增加抽象层的设计
- 优点
    1. 支持基于抽象程度递增的系统设计,使设计者可以把一个复杂系统按递增的步骤进行分解
    2. 支持功能增强. 因为每一层至多和相邻的上下层交互,因此功能的改变最多影响相邻的上下层
    3. 支持重用。只要提供服务接口定义不变,同一层的不同实现可以交换使用.允许定义一组标准接口,不同的实现方式
    
- 缺点
    1. 并不是每个系统都可以很容易地划分为分层模式
    2. 很难找到一个合适的、正确的层次抽象方法

### 独立构件风格
- 独立构件风格强调系统中的每个构件都是相对独立的个体,他们之间不能直接通讯,以降低耦合度，提升灵活度

#### 进程通信架构风格
- 构件时独立的过程，连接件时消息传递.

#### 事件系统风格
- 基于事件的隐式调用风格的思想是构件不直接调用的一个过程,二十触发或广播一个或多个事件


#### 隐式调用的优缺点
- 优点
    1. 为软件重用提供了强大的支持. 当需要将一个构件加入现存系统中时,只需要将它注册到系统的事件中
    2. 为改进系统带来方便。当用一个构件代替另一个构件时，不会影响到其他构建的接口
- 缺点
    1. 构件放弃了对系统计算的控制.
        一个构件触发一个事件时，不能确定其他构建是否会影响它。即使知道了事件注册了那些构件的过程,它也不能保证这些过程被调用的顺序
        
    2. 数据交换问题
        有时数据可被一个事件传递,单另一些情况下,基于事件的系统必须依靠一个共享的仓库进行交互.全局性能和资源管理变成了问题
    3. 既然过程的语义必须依赖于被触发事件的上下文约束.关于正确性的推理存在问题
    


### 虚拟机风格
- 人为构建一个运行环境,在这个环境之上,可以解释与允许自定义的一些语言

#### 解释器
- 一个解释器通常包括完成解释工作的解释引擎
    1. 被解释的代码的存储区
    2. 记录解释引擎当前工作状态的数据结构
    3. 记录源代码被解释执行的进度的数据结构
- 典型例子: 专家系统

#### 规则为中心
- 基于规则的系统包括: 规则集、规则解释器、规则/数据选择器以及工作内存


### 数据库风格
- 数据库系统
    中央共享数据源，保存当前系统的数据状态
    多个独立处理元素，处理元素对数据元素进行操作
- 超文本系统
- 黑板风格
    适合解决复杂的非结构化的问题,能在求解过程中综合运用多种不同知识源,使得问题的表达\组织和丘节变得容易
    组成部分
        1. 知识源
            知识源中包含独立的、与应用程序相关的知识,知识源之间不直接进行通信，它们之间的交互只能通过黑板来完成
        2. 黑板数据结构
            黑板数据是按照与应用程序相关的层次来组织的解决问题的数据,知识源通过不断改变黑板数据来解决问题
        3. 控制
            控制完全由黑板的状态驱动,黑板状态的改变决定使用特定知识
            
            
## 两层及三层C/S架构风格
- C/S架构是基于资源不对等,且为实现共享而提出来的.
- 两层C/S结构为: 单一服务器且以局域网为中心,难以拓展到大型企业广域网或Internet
    问题
        - 服务器的负荷太重，难以管理大量的客户机,系统的性能容易变差
        - 数据安全性不好. 客户端程序可以直接访问数据库服务器,客户端计算机上的其他程序也可能访问数据库服务器

- 三层C/S结构
    三层C/S结构是将应用功能分成表示层、功能层、数据层
    - 表示层
        应用的用户接口部分,承担用户与应用间的对话功能
        用于检查用户的输入,并显示应用输出的数据
        检查的内容只限于数据的形式和取值范围,不包括有关业务本身的逻辑处理
    - 功能层
        相当于应用的本体,它是将具体的业务处理逻辑编入程序中.
        需要处理的数据从表示层或数据层获得.
        表示层和功能层之间的数据交换需要尽可能简洁
    - 数据层
        数据库管理系统.
        负责管理对数据库的读写,

## B/S 架构风格
浏览器/服务器
### 对比 C/S 架构
- B/S架构的不足
    1. B/S 架构缺乏对动态页面的支持能力,没有集成有效的数据库处理功能
    2. 采用B/S架构的应用系统,在数据查询等响应速度上低于C/S架构
    3. B/S架构的数据提交一般以页面为单位,数据的动态交互性不强,不利于在线事务处理(OLTP)应用
    
    
## MVC 架构风格
- Model View Controller 模型-视图-控制器
- 各个部分的分工与协助
    1. Model 是对应用状态和业务功能的封装
        model 接受controller的请求并完成相应的业务处理,在状态改变的时候想view发出相应的通知
    2. View 实现可视化界面的呈现并捕获最终用户的交互操作
    3. view 捕获到用户交互操作后会直接转发给controller, controller 完成UI逻辑
        如果涉及到业务功能的调用 controller 会直接调用model,
        在完成处理后 controller 会根据需要控制原VIEW 或创建新的view对用户交互操作完成响应
        

## MVP 
- 优点
    1. 模型与视图完全分离
    2. 更高效的使用model
    3. 我们将一个 presenter 用户多个视图, 而不改变 presenter 的逻辑
    4. 吧逻辑放在 presenter 中, 那么我们就可以脱离用户接口来测试这些逻辑
- 缺点
    1. 视图渲染在presenter中,视图和 presenter 的交互过于频繁
    2. 视图和 presenter 关系过于密切
    
    
## 面向服务的架构
### 定义
w3c: SOA是一种应用程序架构,在这种架构中,所有功能都定义为独立服务,这些服务带有定义明确的可调用接口,能够以定义好的顺序调用这些服务来组成业务流程
service-architecture.com: 服务是准确定义、封装完善、独立于其他服务所处环境和状态的函数.
    SOA本质上是服务的集合,服务之间彼此通信,这种通信可能是简单数据传输也可能是两个或更多的服务协调进行某些活动
    
### soa设计原则
1. 明确定义的接口
    服务请求者依赖于服务规约来调用服务.
    因此服务定义必须长时间稳定,一旦公布,不能随意更改;
    服务服务的定义应尽可能明确,减少请求者的不适当使用,不让请求者看到服务内部的私有数据
    
2. 自包含和模块化
    服务封装了在业务上稳定,重复出现的活动和构件,实现服务的功能实体是完全独立自主的,独立进行部署、版本控制、自我管理和恢复
3. 粗粒度
    服务数量不应该太多,依靠消息交互而不是远程过程调用,通常消息量比较大,但是服务之间的交互频度较低
4. 松耦合
    服务请求者可见的是服务的接口,其位置、实现技术、当前状态和私有数据等对服务请求者而言不可见
5. 互操作性、兼容和策略声明
    为了确保服务规约的全面和明确,策略成为一个越来越重要的方面
    
### 服务构件与传统构件
1. 服务构件往往是粗粒度的，而传统构件以细粒度居多
2. 服务构件的接口是标准的,主要是服务描述语言接口, 而传统构件通常以具体API形式出现
3. 服务构件的实现与语言无关,传统构件通常绑定某种特定语言
4. 服务构件可以通过构件容器提供QoS的服务,而传统构件完成由程序代码直接控制

### SOA的关键技术
- 与SOA紧密相关的技术 UDDI\WSDL\SOAP\REST...
#### UDDI
- 统一描述、发现和集成.
- UDDI提供了一种服务发布、查找、定位的方法,是服务的信息注册规范
- UDDI 技术规范主要包含一下三个内容
    1. 数据模型
        UDDI数据模型用于描述业务组织和服务的xml schema
    2. API
        UDDI API 是一组用于查找或发布UDDI数据的方法, UDDI API 基于 SOAP
    3. 注册服务
        UDDI 注册服务是SOA中的一种基础设施,对应着服务注册中心的角色


#### WSDL
- web服务描述语言
- WSDL 是服务描述语言, 它基于xml语法定义.
    WSDL 描述的重点是服务, 它包含服务实现定义和服务接口
    采用抽象接口定义对提高系统的可拓展性有帮助.
#### SOAP
- 简单对象访问协议
- SOAP 定义了服务请求者和服务提供者之间的消息传输规范.
- 四个部分
    1. 封装
        SOAP 封装定义了一个整体框架,用来表示消息中包含了什么内容，谁来处理这些内容,以及这些内容是可选的还是必须的
    2. 编码规则
        SOAP 编码规则定义了一种序列化机制,用于交换系统所定义的数据类型的实例
    3. RPC 
        SOAP RPC 表示定义了一个用来表示远程过程调用和应答的协议
    4. 绑定
        SOAP 绑定定义了一个使用底层传输写一来完成在节点之间交换SOAP封装的约定
    
- SOAP 消息基本上是从发送端到接收端的单项传输,SOAP 消息包含如下三个内容
    1. 封装。 封装的元素名: Envelope
    2. SOAP 头, Header
    3. SOAP 体 , Body

#### rest
- 表述性状态转移.
- 设计概念和准则
    1. 网络上的所有事物都被抽象为资源
    2. 每个资源对应一个唯一的资源标识
    3. 通过通用的连接件接口对资源进行操作
    4. 对资源的各种操作不会改变资源的标识
    5. 所有操作都是无状态的
    
### SOA 的实现
- SOA是一种概念和思想.
- SOA 是用本地计算模型来实现的一个分布式计算机应用
- CORBA、DCOM、EJB 都是解决方式

#### web service
- 在 web service 解决方案中由三种角色
    1. 服务提供者(必选)
        服务提供者是服务的所有者，该角色负责定义并实现服务
    2. 服务请求者(必选)
        服务请求者是服务的使用者.
    3. 服务注册中心(可选)
        服务注册中心是链接服务提供者和服务请求的纽带,服务提供者在此发布他们的服务描述,而服务请求者在服务注册中心查找他们所需要的服务.
        
    
- web service 的操作
    1. 发布
        为了使用户能够访问服务,服务提供者需要发布服务描述，以便服务请求者可以找到它
    2. 查找
        在查找操作中,服务请求者直接检索服务描述或在服务注册中心查询所要请求的服务类型
        对服务请求者而言，会在生命周期的两个不同阶段去做查找操作
            1. 设计阶段
                为了程序开发而查找服务的接口描述,
            2. 运行阶段
                为了调用而查找服务的位置描述
    3. 绑定
        在绑定操作中,服务请求者使用服务描述中的绑定细节来定位、联系并调用服务，从而在运行时与服务进行交互》
        绑定的分类
            1. 动态绑定
                服务请求者通过注册中心查找服务描述,并动态的与服务交互
            2. 静态绑定
                服务请求者已经与服务提供者达成默契，通过本地文件或其他方式与服务进行绑定(固定ip访问策略)

- 六个层次
    1. 底层传输层
        底层传输层主要负责消息的传输机制,http jmc smtp 都可以作为服务的消息传输协议
    2. 服务通信协议层
        主要功能:描述并定义服务之间进行消息传递所需的技术标准
            - 常用标准
                1. soap
                2. rest
    3. 服务描述层
        主要以一种统一的方式描述服务的接口与消息交换方式
            - 标准: wsdl
    4. 服务层
        将遗留系统进行包装，并通过发布WSDL接口描述被定位和调用
    5. 业务流程层
        支持服务发现，服务调用，点到点的服务调用,并将业务流程从服务的底层调用抽象出来
    6. 服务注册层
        主要功能: 使服务提供者能够通过WSDL发布服务定义，并支持服务请求者查找所需的服务信息
            - 标准: UDDI

#### 服务注册表
- service registry 。
- 服务注册表主要提供一个策略执行点, 在这个点上服务可以在SOA中注册，从而可以被发现和使用
- 服务注册表包括
    1. 有关服务
    2. 相关构件的配置
    2. 依从性
    3. 约束文件
- 常用功能
    1. 服务注册
        服务注册是指服务提供者向服务注册表发布服务的功能.
        包含属性
            1. 服务身份
            2. 未知
            3. 方法
            4. 绑定
            5. 配置
            6. 方案
            7. 策略
        **限制那些新服务可以向注册表发布,由谁发布以及谁批准和根据什么调价批准,以便服务有序注册**
    2. 服务位置
        服务位置帮助服务使用者查询已注册的服务,寻找符合自身要求的服务.
    
    3. 服务绑定
        服务使用者利用查找到的服务合约来开发代码,开发的代码将与注册的服务进行绑定,调用注册的服务,以及与他们实现活动
        
        
        
#### 企业服务总线
- ESB功能如下
    1. 支持异构环境中的服务、消息、基于事件的交互，并且具有适当的服务级别和可管理性
    2. 使用ESB,可以在几乎不更改代码的情况下,以一种无缝的非入侵方式使现有系统具有全新的服务接口,并能够在部署环境中支持任何标准
    3. 提供诸如服务代理和协议转换等功能
    4. 提供可配置的消息转换翻译机制,基于消息内容的消息路由服务,传输消息到不同的目的地
    5. 提供安全和拥有者机制,保证消息和服务使用的认证、授权和完整性
- ESB 的优势
    1. 扩展的、基于标准的链接
    2. 灵活的、服务导向的应用组合
    3. 提高复用率、降低成本
    4. 减少市场反应时间、提高生产率
    
#### 微服务
- 微服务中每个服务都是一个组件, 通过编排组合的方式来使用,从而真正做到了独立、解耦、组件化、易维护、可复用、可替换、高可用、最终达到提高交付质量、缩短交付周期的效果
- 微服务通常采用轻量级的通信机制(HTTP协议的RESTfulAPI),每个服务都围绕着具体业务进行构建,并且能够独立部署到生产环境

- 优势
    1. 技术异构性
        在微服务架构中,每个服务都是以给相对独立的个体,每个服务都可以选择适用于自生的技术来实现
        - 对比传统单块的系统而言,采用新语言、数据库或者框架都会对整个系统产生巨大的影响。在微服务中我们完全可以只在一个微服务中采用新技术，等到技术成熟后在推广到启发服务
    2. 弹性
        弹性主要讲的是系统中一部分出现故障会引起多大问题. 在单块系统中，一个部分出现问题，可能导致整体系统的问题.而微服务架构中,每个服务可以内置可用性的解决方案与功能降级方案，所以比单块系统强
        
    3. 拓展
        单块系统中,我们要做拓展,往往是整体进行拓展,在微服务架构中可以针对单个服务进行拓展
    4. 简化部署
        在大型单块系统中，即使修改一行代码,也需要重新部署整个应用系统.
        这种部署的影响很大、风险很高,因此不敢轻易的重新部署.在微服务架构中,每个服务都是独立部署,这样可以更快的对特定部分的代码进行部署
    5. 与组织结构更匹配
    6. 可组合性
        在微服务架构中,系统会开放很多接口供外部使用,当情况发生改变时,可以使不同的方式构建应用,而整体化应用程序只能提供一个非常粗粒度的接口供外部使用
    7. 对可替代性的优化
    
- 挑战
    1. 分布式系统的复杂度
        使用微服务实现分布式系统的复杂度要比单块系统高
    2. 维护成本
        相比传统的单块架构应用,微服务将系统分成多个独立的部分,每个部分都是可以独立部署的业务单元.
        意味着,单块架构的集中式部署、配置、监控或者日志收集等方式,在微服务架构下随着服务数量增多,每个服务都需要做上述操作,因此成本指数级增加
    3. 部署自动化
        
    4. DevOps 与组织结构
    5. 服务间依赖测试
        由于服务架构是把系统拆分为若干个可独立部署的服务，所以需要进行服务间的依赖测试
    6. 服务间依赖管理
        传统的单块系统,功能实现比较集中,大部分功能都在一个应用中,同其他系统依赖较少.为父架构将系统功能拆分成互相协作的独立服务后,随着微服务个数增多,如何有效的展现出服务之间的依赖关系成为了挑战


## 架构设计
- 演变交付生命周期
- 属性驱动设计法
    先建立软件架构,再把架构作为骨架,在骨架上循环迭代, 属性驱动设计法(ADD)
    输入: 功能需求(一般表示为用例)、限制条件和质量需求(一组特定于系统的质量场景)
    步骤
        1. 选择需要分解的模块. 通常是整个系统,从系统开始,然后分解为子系统,进一步将子系统分解为子模块
        2. 根据如下步骤对模块求精
            从具体的质量场景和功能需求集中和选择架构驱动因素.
            先满足重要的,在满足不重要的,针对架构需求有优先级
        3. 对需要进一步分解的每个模块重复上述步骤
- 按架构组织开发团队
- 开发股价系统
- 利用商用构件进行开发

## 软件架构文档化
- 记录软件架构的活动就是架构编档过程,也就是架构的文档化
    1. 过程,编档过程能促使架构设计师进一步的思考,使得架构更加完善
    2. 结果,描述架构的文档将作为架构开发的成果,共项目关系人使用

1. 架构文档的使用者
    架构文档的使用这是架构的项目关系人.
2. 合理的编档规则编写架构文档和编写其他文档一样,也需要遵守一些基本规则.
    1. 从读者的角度编写文档
    2. 避免出现不必要的重复
    3. 避免歧义
    4. 使用标准结构
    5. 记录基本原理
    6. 文档保持更新, 但更新频率不要过高
    7. 针对目标的适宜性对文档进行评审
3. 视图编档
    1. 视图概述
        对系统进行概括性的描述,包含视图的主要元素和元素之间的关系
    2. 元素目录
        对主要表示中所描述的元素及其关系进行详细描述
    3. 上下文图
        用图形展示系统如何与其环境相关
    4. 可变性指南
        描述架构的可变化点
    5. 架构背景
        为架构的合理性提供足够的、令人信服的论据
            基本原理、分析结果
    6. 术语表
        对每个属于进行简要说明
    7. 其他信息
        描述不属于架构方面的必要信息
        
4. 跨试图文档
5. UML
6. 软件架构重构
    重构的主要活动
        1. 信息提取
        2. 数据库构造
            将提取的信息转化为标准的形式,并放入数据库
        3. 视图融合
            将数据库中的信息组合到一起,生成该架构的一个内聚视图
        4. 重构
            构件数据抽象和各种表示以生成架构表示
                可视化、交互、模式定义、识别
        

## 软件架构评估
- 基于问卷或检查表
    该方式的关键是要如何设计问卷,缺点: 依赖评估人的主观判断
- 基于场景
    通过分析软件架构对场景的支持度，从而判断该架构对这一场景所代表的质量需求的满足程度
   
- 基于度量
    它是建立在软件架构度量的基础上,三个基本活动
        1. 需要建立质量属性和度量之间的映射原则. 即确定怎样从度量结果中退出系统具有什么样的质量属性
        2. 从软件架构文档中获取度量信息
        3. 根据映射原则分析推导出系统的质量属性
        
### 架构的权衡分析法
#### ATAM 产生如下结果
- 一个简洁的构件描述
    ATAM 的一个要求是在一个小时内表述架构,这样就得到了一个简介、可理解、面向普通关系人的架构表述. 他是从架构文档中提炼形成
- 表述清楚的业务目标
- 采用场景集合捕获质量需求
- 架构决策到质量映射的需求
- 所确定的敏感点和权衡点的集合
    - 这个集合是一些对一个或多个质量属性具有显著影响的架构决策
- 有风险决策和无风险决策
- 风险主题的集合
- 产生一些附属结果
- 产生一些无形结果

#### ATAM 的步骤
1. ATAM 方法表述
2. 商业动机的表述
3. 架构的表述
4. 对架构方法进行分类
5. 生成质量属性效用树
6. 分析架构方法
7. 集体讨论并确定场景的优先级
8. 分析架构方法
9. 结果表述

结果 
    1. 已编写了文档的架构方法
    1. 经过讨论得到的场景集合及其优先级
    1. 效用树
    1. 所发现的有风险策略
    1. 已编成文档的无风险策略
    1. 所发现的敏感点和权衡点


#### 成本效益分析法
- CBAM 在ATAM上构建

- 步骤
    1. 整理场景
    2. 对场景进行求精
    3. 确定场景优先级
    4. 分配效用
    5.架构策略涉及那些质量属性及响应级别
    6. 使用内插法确定期望的质量属性影响级别的效用
    7. 计算各架构策略的总收益
    8 根据ROI选择架构策略
    
## 构件及其复用
### 定义
    1. 构件是指软件系统中明确辨识的构成成分
        可复用构件是指具有相对独立的功能和可复用价值的构件
    2. 构件是一个组装单元,它具有约定式规范的接口及明确的依赖环境
    3. 构件是软件系统中具有相对独立功能、可以明确辨识、接口由契约指定和语境由明显依赖关系、可独立部署的可组装软件实体
    
    
### 商用构件标准规范
- CORBA 公共对象请求代理框架,三个层次
    1. 对象请求代理
    2. 公共对象服务
    3. 公共设施
    用于开发和配置分布式应用的服务器端构件模型规范
        1. 抽象构建模型
            用以描述服务端构件结构及构件间互操作的结构
        2. 构件容器结构
            用以提供通用的构件运行和管理环境，并支持安全、事务、持久态等系统服务的集成
        3. 构件的配置和打包规范
            CCM 使用打包技术来管理构件的二进制,多语言版本的可执行代码和配置信息,并定制了构件包的具体内容和文档内容标准
            
- J2EE
- DNA 2000



## 产品线及系统演化

### 复用与产品线
可复用的内容  
    1. 需求
    1. 架构设计
    1. 元素
    1. 建模与分析
    1. 测试
    1. 项目规划
    1. 样本系统
    1. 缺陷消除

#### 产品线架构
- 基于产品线的架构,相交单个产品架构有三个特点
    1. 产品线架构必须考虑一系列明确许可的变化
    2. 产品线架构一定要文档化
    3. 产品线架构必须提供"产品创建者指南",描述架构的实例化过程
- 需要考虑的几个面
    1. 确定变化点
    2. 支持变化点
    3.对唱片线架构的适宜性进行评估

- 产品线的开发模型
    1. 前瞻性产品线
    2. 反应性产品线


#### 特定领域架构
- 特定领域软件架构的特征
    1. 一个严格定义的问题域或解决域
    2. 具有普遍性
    3. 具备该领域固定的、典型的在开发过程中可复用元素
    - 从功能覆盖的范围角度可以分为
        1. 垂直域: 定义了一个特定的系统族,导出在该领域中可作为系统的可行解决方案的一个通用软件架构
        2. 水平域: 定义了在多个系统和多个系统族中功能区域的共有部分,在子系统级上涵盖多个系统(族)的特定部分功能
        
        
        
- DSSA 的主要活动
    1. 领域分析
        主要目标是活的领域模型
    2. 领域设计
        主要目标获得DSSA
    3. 领域实现
        主要目标是依据领域模型和DSSA 开发与组织可复用信息
        
- 领域模型的主要作用
    1. 领域模型为需求定义了知识领域和领域词汇，这较之单一的项目需求更友好的大局观
    2. 软件界面的设计往往和领域模型关系密切
    3. 领域模型的合理性将严重影响软件系统的可拓展性
    4. 在分层架构的指导下，领域模型精化后即成为业务层的骨架
    5. 领域模型也是其数据模型的基础
    6. 领域模型是团队交流的基础,它规定了重要的领域词汇表，并且这些词汇的定义是严格的、大家认可的
    

#### 架构及系统演化
- 需求变动归类
- 定制架构演化计划
- 修改、增加或删除构件
- 更新构件的互相作用
- 构件组装与测试
- 技术评审
- 产生演化后的架构


## 软件架构试图
- 三种类型
    1. 模块视图类型
        为系统的主要模块实现单元编档
    2. 构件和连接件视图类型
        为系统的构件和连接件执行单元编档
    3. 分配视图类型
        为软件的开发和执行环境之间的关系编档
        
### 模块视图
1. 分解风格能展示向模块分配责任的方式
2. 使用风格能展示模块相互依赖的方式
3. 分层风格能将系统分割成一组虚拟机,通过允许使用关系互相关联,分层风格能帮助实现可移植性和可修改性
4. 泛化风格还能展示一个模块如何成为另一个模块的泛化或特化,从而使模块之间产生关联


### c&c 视图类型及其风格
- 管道和过滤器风格中的交互模式表现出数据流连续变换的特征
- 共享数据风格通过保留持久数据来支配交互模型,持久数据由多个数据存取器和至少一个存储库保留
- 发布-订阅风格用于向一组未知接受者发送事件和消息
- 客户机-服务器风格能展示构件通过请求其他构件的服务进行交互的过程,将功能划分成客户机和服务器后可基于运行时准则把他们单独分配给各个级
- 对等链接系统能够通过构件之间的直接交换支持服务交换.是一种调用/返回风格
- 通信-进程风格的特征表现在通过各种连接件机制并发执行构件的交互